{"pages":[{"title":"文章分类","text":"","link":"/tags/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"Singleton","text":"Java单例模式的不同写法（懒汉式、饿汉式、双检锁、静态内部类、枚举）单例模式优点 它能够避免实例对象的重复创建，不仅可以减少每次创建对象的时间开销，还可以节约内存空间； 能够避免由于操作多个实例导致的逻辑错误。 如果一个对象有可能贯穿整个应用程序，而且起到了全局统一管理控制的作用，那么单例模式也许是一个值得考虑的选择。 总结：避免重复创建，节约时空消耗，适合全局统一管理 饿汉模式1234567public class Singleton{ private static Singleton instance = new Singleton(); private Singleton(){} public static Singleton newInstance(){ return instance; }} 构造函数 private，其他类无法实例化 静态方法返回 实例 在类加载的时候就已经创建，整个程序周期存活 类加载时创建，避免多线程创建多实例，多线程同步问题 缺点，没被用到也会被创建（感觉问题不大啊） 适合情况: 单例对象占用内存小,初始化时就会被用到 懒汉模式- 延迟加载12345678910public class Singleton{ private static Singleton instance = null; private Singleton(){} public static Singleton newInstance(){ if(null == instance){ instance = new Singleton(); } return instance; }} 需要的时候才去创建 单例对象创建成本高,使用次数少,按需创建 缺点:未考虑线程安全,加锁解决线程同步问题 synchronized 双重校验锁 加锁的懒汉模式,由于锁的存在,所以导致性能问题, synchronized会导致比一般方法慢得多 1234567891011121314public class Singleton { private static Singleton instance = null; private Singleton(){} public static Singleton getInstance() { if (instance == null) { // Single Checked synchronized (Singleton.class) { if (instance == null) { // Double checked instance = new Singleton(); } } } return instance; }} 这代码很有想法 平时调用getInstance直接返回实例,不存在锁的问题 第一次调用,如果出现多线程,那么内部同步方法保证了依次执行 同事 同步方法内再次校验 实例是否创建,简直万无一失啊 双检锁隐患： Java指令重排优化。在不改变原语义的情况下，通过调整指令的执行顺序让程序运行的更快 JVM未规定编译器优化相关的内容，所以JVM可以自由的进行指令重排序的优化。 instance = new Singleton() 并不是一个原子操作 给 instance 分配内存 调用 Singleton 的构造函数来初始化成员变量 将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了） 由于第二三部不保证,所以如果出现 1-3-2,然后在3 执行完毕、2 未执行之前，被线程二抢占了,instance非null,导致线程二返回未初始化的Instance,就会报错 java 指令重排优化 的解决方案1private volatile static Singleton instance; 加入volatile volatile特性: 禁止指令重排化 静态内部类 优秀 类加载机制来保证只创建一个instance实例。它与饿汉模式一样，也是利用了类加载机制，因此不存在多线程并发的问题。 内部类里面去创建对象实例。 只要应用中不使用内部类，JVM就不会去加载这个单例类，也就不会创建单例对象，从而实现懒汉式的延迟加载。也就是说这种方式可以同时保证延迟加载和线程安全。 123456789public class Singleton{ private static class SingletonHolder{ public static Singleton instance = new Singleton(); } private Singleton(){} public static Singleton newInstance(){ return SingletonHolder.instance; }} enum单例模式1234567891011121314151617181920212223242526272829public class EnumSingleton{ private EnumSingleton(){} public static EnumSingleton getInstance(){ return Singleton.INSTANCE.getInstance(); } private static enum Singleton{ INSTANCE; private EnumSingleton singleton; //JVM会保证此方法绝对只调用一次 private Singleton(){ System.out.println(\"Singleton 初始化\"); singleton = new EnumSingleton(); } public EnumSingleton getInstance(){ return singleton; } } public static void main(String[] args) { System.out.println(\"main start\"); EnumSingleton obj1 = getInstance(); EnumSingleton obj2 = getInstance(); //输出结果：obj1==obj2?true System.out.println(\"obj1==obj2?\" + (obj1==obj2)); System.out.println(Singleton.INSTANCE.getClass().getName()); }}//第一次调用 Singleton会导致构造函数执行,之后不会也就是jvm保证此方法绝对只调用一次 总结（1）饿汉式：线程安全 （2）懒汉式：非线程安全 （3）双检锁：线程安全 （4）静态内部类：线程安全 （5）枚举：线程安全 链接 http://chen-tao.github.io/2016/12/30/about-java-singleton/ https://blog.csdn.net/fly910905/article/details/79286680","link":"/Singleton.html"},{"title":"builder设计模式","text":"设计模式之建造者模式定义将一个复杂的对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 看定义感觉和工厂模式很像啊 组成Builder：抽象 产品的生成步骤123456public interface ComputerBuilder { void buildCpu(); void buildGpu(); void buildMotherBoard(); Computer buildComputer();} ConcreteBuilder：实现builder,不同产品 采用不同的ConcreteBuilder由于不同产品拥有不同的生产过程,所以不同产品不同ConcreteBuilder 如果两个产品之间只有部分修改,可以考虑通过继承,override修改部分功能 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 public class AmdBuilder implements ComputerBuilder { Computer com; public AmdBuilder(){ com = new Computer(); } public void buildCpu(){ com.setCpu(\"AMD\"); } public void buildGpu(){ com.setGpu(\"AMD Radeon\"); } public void buildMotherBoard(){ com.setMother_board(\"asus\"); } public Computer buildComputer(){ return com; } }public class IntelBuilder implements ComputerBuilder { Computer com; public IntelBuilder(){ com = new Computer(); } public void buildCpu(){ com.setCpu(\"Intel\"); } public void buildGpu(){ com.setGpu(\"Navi\"); } public void buildMotherBoard(){ com.setMother_board(\"华擎\"); } public Computer buildComputer(){ return com; } } Director：把 所有的生产步骤联系起来,最终生产出产品12345678public class ComDirector{ public Computer constructCom(ComputerBuilder CB){ CB.buildCpu(); CB.buildGpu(); CB.buildMotherBoard(); return CB.buildComputer(); }} Product：要生产的产品框架123456789101112131415161718192021222324252627282930public class Computer{ private String cpu; private String gpu; private String mother_board; public String getCpu(){ return cpu; } public void setCpu(String cpu){ this.cpu = cpu; } public String getGpu(){ return gpu; } public void setGpu(String gpu){ this.gpu = gpu; } public String getMother_board(){ return mother_board; } public void setMother_board(String MB){ this.mother_board = MB; }}","link":"/builder设计模式.html"},{"title":"java_enum","text":"深入剖析Java枚举类 某个变量取值仅限于集合中的元素。此时，可将这些数据集合定义为枚举类型。 枚举类型是某类数据可能取值的集合 由于枚举类型是导出数据类型，因此，必须先定义枚举类型，然后再用枚举类型定义枚举型变量。 编译器编译程序时，会给枚举类型中的每一个元素指定一个整型常量值(也称为序号值)。 若枚举类型定义中没有指定元素的整型常量值，则整型常量值从0开始依次递增 12 {red=5,blue=1,green,black,white,yellow}; 该定义规定red为5 ，blue为1，其后元素值从2 开始递增加1。green、black、white、yellow的值依次为2、3、4、5。 语法 enum 与 class、interface 具有相同地位； 可以继承多个接口； 可以拥有构造器、成员方法、成员变量； 默认继承 java.lang.Enum 类，所以不能继承其他父类； java.lang.Enum 类实现了 java.lang.Serializable 和 java.lang.Comparable 接口； 使用 enum 定义，默认使用 final 修饰，因此不能派生子类； 构造器默认使用 private 修饰，且只能使用 private 修饰； 枚举类所有实例必须在第一行给出，默认添加 public static final 修饰，否则无法产生实例； 每个枚举类第一个都是实例成员.,实例实例 关联 单例模式,static修饰枚举类,instance 深入阅读参考链接https://h2pl.github.io/2018/05/02/javase15/","link":"/java-enum.html"},{"title":"csrf referer空绕过新思路","text":"csrf referer空绕过新思路面试创宇被问到利用csrf过程中,如何使referer头部为空,脑中突然闪过一条新闻 新浪微博图片增加referer校验,导致图床大面积失效 记得当时一个解决办法是添加no referer这个html头,来达到referer空的目的.给面试官说了下思路.面试完抓紧测一波. 实验代码直接csrf含有 referer代码123456789&lt;html&gt; &lt;head&gt; &lt;title&gt;文档标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;This is a paragraasdfph&lt;/p&gt; &lt;img src=\"http://blog.azero-ng.cn\"&gt; &lt;/body&gt;&lt;/html&gt; 结果如下:果然有referer头部 头部添加meta12345678910&lt;html&gt; &lt;head&gt; &lt;title&gt;文档标题&lt;/title&gt; &lt;meta name=\"referrer\" content=\"no-referrer\"&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;This is a paragraasdfph&lt;/p&gt; &lt;img src=\"http://blog.azero-ng.cn\"&gt; &lt;/body&gt;&lt;/html&gt; referer头部消失了 元素添加 referrerPolicy=”no-referrer”123456789&lt;html&gt; &lt;head&gt; &lt;title&gt;文档标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;This is a paragraasdfph&lt;/p&gt; &lt;img src=\"http://blog3.azero-ng.cn\" referrerPolicy=\"no-referrer\"&gt; &lt;/body&gt;&lt;/html&gt; referer 头部消失 注意，元素添加取消referer参数，网上有多种写法，但是有的无法成功，目前使用的，是mdn官方推荐，并已在chrome 74 测试通过。 参考链接MDN 官方文档对 head Referrer-Policy 的介绍，强烈推荐阅读 https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy MDN官方文档 对图像元素referrerPolicy（HTMLImageElement.referrerPolicy）的介绍，强烈推荐 https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/referrerPolicy#Browser_compatibility 不错的文章 https://juejin.im/entry/5adaa72c6fb9a07aa43bc665 有点老了，不太推荐 https://imququ.com/post/referrer-policy.html csrf绕过技巧 https://zhuanlan.zhihu.com/p/50619269","link":"/csrf-bypass-referer.html"},{"title":"nginx_apache_php_上传文件限制","text":"nginx 上传文件限制client_max_body_size 150M 必须要放在server下的server_name下 nginx -s reload apache 上传文件限制.htaccess LimitRequestBody 1024000000 php 上传文件限制12345upload_max_filesize: 上传的文件的最大大小post_max_size: POST数据所允许的最大大小max_execution_time: 脚本最大执行时间max_input_time: 脚本解析请求数据消耗的最大时间memory_limit:一个脚本所能够申请到的最大内存字节数 mysql 最大sql语句限制Err [Imp] 1153 - Got a packet bigger than ‘max_allowed_packet’ 在MySQL安装目录下找到文件my.cnf，搜索[mysqld]，在其下面添加一句话 max_allowed_packet=150M systemctl restart mariadb","link":"/nginx-apache-php-上传文件限制.html"},{"title":"python-协程篇1","text":"python 协程协程运行asyncio.run() await asyncio.create_task() 可等待对象 协程 协程函数: 定义形式为 async def 的函数; 协程对象: 调用 协程函数 所返回的对象。 任务 asyncio.create_task(coro):将 coro 协程 打包为一个 Task 排入日程准备执行。返回 Task 对象。 Future Future 是一种特殊的 低层级 可等待对象，表示一个异步操作的 最终结果。 loop.run_in_executor()。 运行asyncio程序 asyncio.run(coro, *, debug=False): 同线程下,无eventloop,才能被调用,理想情况:作为主入口点,只被调用一次 创建任务asyncio.create_task(coro): 把协程对象包装成task对象 阻塞coroutine asyncio.sleep(delay, result=None, *, loop=None) loop即将废弃 并行执行任务awaitable asyncio.gather(*aws, loop=None, return_exceptions=False) aws:task序列,可等待对象自动转换成task 屏蔽取消操作以后再看 awaitable asyncio.shield(aw, *, loop=None) 超时asyncio.wait_for(aw, timeout, *, loop=None) 超时,发送cancellation 等待直到aw确实结束了,所以运行时间&gt;=timeout waiting primitives coroutine asyncio.wait(aws, *, loop=None, timeout=None, return_when=ALL_COMPLETED) 并行运行aws,并阻塞直到 return_when条件达成 超时wait不会cancel 返回done,pending 由于会自动把 coro 转成task,导致coro不会出现在done或pending(里面是task) asyncio.as_completed(aws, *, loop=None, timeout=None) 返回Future对象迭代器,表示最早出结果的aw 如果超时(所以futures没有在timeout内完成),raise asyncio.TimeoutError 来自其他线程调度(schedule)暂时用不到,以后再看 Introspection 内省 asyncio.current_task(loop=None):返回loop正在运行的task asyncio.all_tasks(loop=None):返回还没有完成的 task集合 Task 对象 类future,非线程安全 一个coro在await future,task会把coro suspend,然后等待future 完成,然后resume coro,继续运行 事件循环使用cooperative scheduling:一个事件循环同时只执行一个task,当一个task等待future完成时:事件循环会接着运行其他task,callbacks,或者执行io 操作 创建事件: asyncio.create_task() loop.create_task() ensure_future() 取消 cancel:task会向coro发送CancelledError,如果在等待future,future会被cancel cancelled:判断task是否确实被cancelled() Task 从 Future 继承了所有APIs ,除了 Future.set_result() and Future.set_exception(). API:all_tasks cancel cancelled done result:返回结果 exception:返回coro抛出的异常,否则None add_done_callback:完成回调,详见Future remove_done_callback(callback): get_stack print_stack","link":"/python-协程篇1.html"},{"title":"命令模式","text":"命令模式介绍 目的:将一个请求封装成一个对象 解决的问题: 行为请求者与行为实现者通常是一种紧耦合的关系.但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。 如何解决: 通过调用者调用接受者执行命令，顺序：调用者→接受者→命令。 关键角色: received 真正的命令执行对象 Command invoker 使用命令对象的入口 优点： 降低了系统耦合度。 新的命令可以很容易添加到系统中去 使用场景：认为是命令的地方都可以使用命令模式，比如： 1、GUI 中每一个按钮都是一条命令。 2、模拟 CMD。 实现Receiver 具体命令执行者1234567891011121314public class Receiver { private String name = \"ABC\"; private int quantity = 10; public void buy(){ this.quantity++; System.out.println(\"Stock [ Name: \"+name+\", Quantity: \" + quantity +\" ] bought\"); } public void sell(){ this.quantity--; System.out.println(\"Stock [ Name: \"+name+\", Quantity: \" + quantity +\" ] sold\"); }} Order 命令对象Order借口123public interface Order { void execute();} 具体Order实现1234567891011121314151617181920212223public class BuyOrder implements Order { private Receiver abcStock; public BuyOrder(Receiver abcStock){ this.abcStock = abcStock; } public void execute() { abcStock.buy(); }}public class SellOrder implements Order { private Receiver abcStock; public SellOrder(Receiver abcStock){ this.abcStock = abcStock; } public void execute() { abcStock.sell(); }} Invoker命令序列同意调用者1234567891011121314public class Invoker { private List&lt;Order&gt; orderList = new ArrayList&lt;Order&gt;(); public void takeOrder(Order order){ orderList.add(order); } public void placeOrders(){ for (Order order : orderList) { order.execute(); } orderList.clear(); }}","link":"/命令模式.html"},{"title":"简单工厂模式","text":"简单工厂模式","link":"/简单工厂模式.html"},{"title":"代理模式","text":"介绍 目的:为其他对象提供一种代理以控制对这个对象的访问。 解决问题:直接访问对象时带来的问题 优点： 1、职责清晰。 2、高扩展性。 3、智能化。 注意事项： 和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。 疑问:和单例模式什么区别 组成接口123public interface Image { void display();} 被代理123456789101112131415161718public class RealImage implements Image { private String fileName; public RealImage(String fileName){ this.fileName = fileName; loadFromDisk(fileName); } @Override public void display() { System.out.println(\"Displaying \" + fileName); } private void loadFromDisk(String fileName){ System.out.println(\"Loading \" + fileName); }} 代理类1234567891011121314151617public class ProxyImage implements Image{ private RealImage realImage; private String fileName; public ProxyImage(String fileName){ this.fileName = fileName; } @Override public void display() { if(realImage == null){ realImage = new RealImage(fileName); } realImage.display(); }}","link":"/代理模式.html"},{"title":"编译原理-语法分析","text":"语法分析基础概念归约和推导推导：用产生式的右部替换产生式的左部规约：用产生式的左部替换产生式的右部 最左推导: 最左非终结符号进行替换最右推导: 最右非终结符号进行替换 最左归约: 最左终结符号进行替换最右归约: 最右终结符号进行替换 规范推导: 最右推导称为规范推导最右推导对应于最左规约: 想象一下,最右推导从后往前逆,就是最左归约 句型和句子 文法: 123 S→AB A→aA|a B→bB|b 用上述文法推导字符串aaabbb过程如下： S→AB→aAB→aaAB→aaaB→aaabB→aaabbB→aaabbb 句型: AB、aAB、aaAB、aaaB、aaabB、aaabbB和aaabbb都是上述文法的一个句型 句子: 全部由终结符组成的句型叫句子,如:aaabbb短语,直接（简单）短语,句柄定义短语、简单短语都是针对某一句型的，是相对于某个非终结符号的，并且任何句型本身一定是相对于识别符号Z的短语。 语法树版实例文法12S-&gt;(L)|aS|aL-&gt;L,S|S 分析(S,(a)) 语法树 短语一个句型的语法树中任一子树叶节点所组成的符号串都是该句型的短语。 第二层: (S,(a)) 第三层: S,(a) 第四层: S (a) 第五层: a 直接（简单）短语当子树不包含其他更小的子树时，该子树叶节点所组成的字符串就是该句型的直接短语直接短语: a S 句柄句柄是最左边的直接短语句柄:S 素短语(待完善):这个含有到底是怎么含有,能推导算含有吗?素短语是一个短语，它至少含有一个终结符，而且除他之外不含有其他素短语。短语包含素短语，我们可以直接在短语中判断。因为S可以推导出其他字符，(a);S,(a);(S,(a))都包含其他素短语，所以符合条件的只有a. 个人理解(给我看的)短语 是 句型的一部分,可以归约成一个非终结符号所以句柄就是最左边,可以最先归约成一个非终结符号 语法树(todo)语法分析的方法自顶向下分析 推导过程递归下降分析LL(1)分析自底向上分析 归约过程一般分析方法概述 分析思想:移进–归约(Shift-Reduce) 解决问题:寻找当前句型的句柄 分析方法:利用一个符号栈来记录分析的历史和指示分析下一步动作. 动作(有点连连看的意思啊,对对碰) 移进:将输入串中的一个符号移进栈里; 归约:当栈顶呈现句柄时用相应的规则替换; 接受:宣布分析成功,此时栈顶只有一开始符号; 出错:栈顶内容与输入串相悖,分析无法进行;理解 句柄为什么会呈现在栈顶? 句柄是句型最左边的简单短语;栈内和栈外符号构成当前句型。 如何快速准确寻找当前句型的句柄. 需要通过算法解决,而不能利用语法树. 不同的文法有不同的寻找句柄的方法 简单优先文法: 最左归约,解决算术(逻辑)表达式的分析 算符优先文法: “最左归约”,解决算术(逻辑)表达式的分析 LR分析法: LR(0)文法 SLR(1)文法 LR(1)文法 最左归约,可分析无二义性上下文无关文法 简单优先分析 优先关系 若X与Y的优先级相等 $ X \\eqcirc Y$ 若X的优先级比Y的优先级高$ X \\gtrdot Y$ 若X的优先级比Y的优先级低$ X \\lessdot Y $ 优先关系判定 $ X \\eqcirc Y$：当且仅当G中存在产生式规则A → …XY… $ X \\lessdot Y$：当且仅当G中存在产生式规则A → …XB..，B → Y….【B规约了，X才能规约】 $ X \\gtrdot Y $：当且仅当G中存在产生式规则A → …BC…，B → …X，C → Y…【最左规约，先规约B】 寻找句柄 在任何规范句型中,满足以下条件的最左子串 最左字符大于左面的字符 最右字符大于右面的字符 内部字符优先级相等 执行算法,读入一个单词后,比较栈顶符号和该单词的优先级: 若栈顶符号优先级低于该单词，继续入栈； 等于时，寻找句柄进行规约 若栈顶符号优先级高于该单词,句柄寻找完毕,向栈内寻找句柄尾部,规约,再次比较优先级 直至最终栈内只剩下开始符号，输入带剩下#，此时识别正确。 文法限制 任意两个字符之间只存在唯一的一种关系（等于，小于或者大于） 任意两个产生式没有相同的右部,无二义性 简单优先关系矩阵 矩阵元素只有为空或者其中一种优先关系 为空表示没有任何句型中存在这两个符号的相邻，遇见这种相邻就是错误的 #的优先级小于所有符号，所有符号的优先级大于#【当然是它们相邻的情况下才有这种关系】 优缺点 说明:只有相邻的符号之间才存在优先级，并且优先级是唯一 缺点:适用范围小（只针对简单优先文法）；分析表尺寸过大（都需要去它们之间的关系） 优点：技术简单 局限性: 多重定义优先关系—-非简单优先文法,解决方法:改写文法 文法的复杂性增加,改写不能解决,解决方法LR(K)分析法 在实际的运算过程中,决定运算顺序的是终结符号之间的优先关系. 算符优先分析法:只考虑终结符号之间的优先关系 算符优先分析算符优先分析法 算符文法OG 设一文法G,若G中不含U→…VW…规则,V, W∈Vn 算符优先文法(OPG) 前提:og文法 a=b:如U→….ab….或U→….aVb… a\\&lt;b:有形如U→….aW….的规则,且W=+>b….或W=+&gt;Vb….. a&gt;b:有形如U→….Wb….的规则,而且W=+&gt; …. a或W=+&gt;….aV 算符优先分析算法设计 素短语:至少包含有一个终结符号,并且除它自身之外,不再包含其它任何更小的素短语。 算符优先文法句型的一般形式:N 1a1N 2a2 …… NnanNn+1# ai∈Vt,Ni ∈Vn(可有可无) 最左素短语的确定,满足以下条件的最左子串Njaj…..Niai N i+1 a j-1 &lt; aj aj = a j+1 = … = a i-1 = ai ai &gt; a i+1 类似简单文法分析,但是只是终结符 分析流程: 先找最左素短语的头部( 首次满足&gt; ) 再找最左素短语的尾部( 首次满足&lt; ) 中间夹的终结符号优先级相等 = 算符优先关系矩阵构造 $ A \\eqcirc B $ 查规则 $ A \\lessdot B$ 或 $ A \\gtrdot B$ 构造两个集合FIRSTVT(U) LASTVT(U) FIRSTVT(U)={b∣U=+&gt;b…, 或U =+&gt; Vb…, b∈Vt,V∈V n } 则形如W→…aU…的规则a &lt; b,b ∈ FIRSTVT(U) LASTVT(U)={a∣U=+&gt;…a, 或U =+&gt;…aV, a∈Vt, V ∈Vn } a &gt; b,a ∈LASTVT(U) 构造算法: 初始化:U→b…, 或U→Vb…,则b ∈ FIRSTVT(U) 循环: U →V…,且b ∈ FIRSTVT(V) 则b ∈ FIRSTVT(U) 算法分析(不推荐,效率太低) 初始:F(U,b)初值(根据原则1),F(U,b)为真的(U,b)对进STACK栈 循环:直至STACK空(根据原则2) 弹出栈顶元素,记(V,b)对每一个形如U→V…的规则若F(U,b) 为假,变为真, 进STACK栈若F(U,b)为真,再循环 LR分析法Todo [ ] 语法树 [ ] 树的概念 简单子树,二叉树,等等 新开一篇文章引用链接 句子和句型编译原理句子和句型的区别 短语,直接（简单）短语,句柄编译原理：短语，简单短语，句柄，语法树通过语法树判断,写的非常清晰 简单优先分析法编译原理-简单优先分析法","link":"/编译原理-语法分析.html"},{"title":"装饰器模式","text":"介绍 目的:动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。 解决问题:继承方式会导致子类过多问题 适用场景:在不想增加很多子类的情况下扩展类。 组成结构: Component 类充当抽象角色，不应该具体实现。 修饰类引用和继承 Component 类，具体扩展类重写父类方法。 实现被装饰类被装饰类接口123public interface Memory { void output();} 具体实现被装饰类12345public class DDR3 implements Memory { public void output() { System.out.println(\"DDR3 Memory\"); }} 12345public class DDR4 implements Memory { public void output() { System.out.println(\"DDR4 Memory\"); }} 装饰类装饰类接口1234567891011public abstract class MemoryDecorator implements Memory { protected Memory mem; public MemoryDecorator(Memory decoratedShape){ this.decoratedShape = decoratedShape; } public void output(){ decoratedShape.output(); } } 装饰器实现12345678910public class KinstomDecorator extends MemoryDecorator{ public KinstomDecorator(Memory mem){ super(mem); } public void output(){ System.out.print(\"Kinstom's \"); this.mem.output(); }} 调用12345678910111213public void run(){ Memory ddr3 = new DDR3(); KinstomDecorator kinsddr3 = new KinstomDecorator(new DDR3()); System.out.println(\"DDR3 output:\"); ddr3.output(); System.out.println(\"kinstom's DDR3 output:\"); kinsddr3.output(); System.out.println(\"kinstom's DDR4 output:\"); new KinstomDecorator(new DDR4()).output();}","link":"/装饰器模式.html"},{"title":"观察者模式","text":"观察者模式介绍 意图:对象一对多的依赖关系,一个状态改变,则通知所有依赖对象 解决问题: 一个对象改变如何通知给其他对象问题 何时使用: 一对多依赖关系,广播通知 关键代码：在抽象类里有一个 ArrayList 存放观察者们优点： 观察者和被观察者是抽象耦合的。 建立一套触发机制。缺点 观察者过多,通知会花费较多时间 循环依赖 观察者只知道改变了,不知道改变原因实现subject 1234567891011121314151617181920212223import java.util.ArrayList;import java.util.List;public class Subject { private List&lt;Observer&gt; observers = new ArrayList&lt;Observer&gt;(); private int state; public void setState(int state) { this.state = state; notifyAllObservers(); } public void attach(Observer observer){ observers.add(observer); } public void notifyAllObservers(){ for (Observer observer : observers) { observer.update(state); } }} Observer1234public abstract class Observer { protected Subject subject; public abstract void update(int state);} concret Observer1234567public class BinaryObserver extends Observer{ @Override public void update(int state) { System.out.println( \"Binary String: \" + Integer.toBinaryString( state ) ); }} 调用12345678910111213public void run(){ BinaryObserver a = new BinaryObserver(\"a\"); BinaryObserver b = new BinaryObserver(\"b\"); BinaryObserver c = new BinaryObserver(\"c\"); Subject cause = new Subject(); cause.attach(a); cause.attach(b); cause.attach(c); cause.setState(1154);}","link":"/观察者模式.html"},{"title":"记一次archlinux莫名鼠标键盘失灵","text":"有一天开机突然发现键盘鼠标失灵了 修改内核参数,加入single进入单例模式 journalctl -xb 搜索 fail 发现virtual box项 关闭virtual box加载的几个模块 重启 搞定","link":"/记一次archlinux莫名鼠标键盘失灵.html"},{"title":"适配器模式","text":"适配器模式适用场景 组成部分 目标接口（Target）：客户所期待的接口。目标可以是具体的或抽象的类，也可以是接口。 需要适配的类（Adaptee）：需要适配的类或适配者类。 适配器（Adapter）：通过包装一个需要适配的对象，把原接口转换成目标接口。 实现方式１ 类的适配器模式（采用继承实现）12345678910111213141516171819202122232425262728293031323334353637// 已存在的、具有特殊功能、但不符合我们既有的标准接口的类class Adaptee { public void specificRequest() { System.out.println(\"被适配类具有 特殊功能...\"); }} // 目标接口，或称为标准接口interface Target { public void request();} // 具体目标类，只提供普通功能class ConcreteTarget implements Target { public void request() { System.out.println(\"普通类 具有 普通功能...\"); }} // 适配器类，继承了被适配类，同时实现标准接口class Adapter extends Adaptee implements Target{ public void request() { super.specificRequest(); }} // 测试类public class Client { public static void main(String[] args) { // 使用普通功能类 Target concreteTarget = new ConcreteTarget(); concreteTarget.request(); // 使用特殊功能类，即适配类 Target adapter = new Adapter(); adapter.request(); }} 重点看Adapter类,继承adaptee,实现target接口,接口内部 调用真正起作用的函数.最后客户使用Adapter的接口 对象适配器 直接关联1234567891011121314151617181920212223242526272829// 适配器类，直接关联被适配类，同时实现标准接口class Adapter implements Target{ // 直接关联被适配类 private Adaptee adaptee; // 可以通过构造函数传入具体需要适配的被适配类对象 public Adapter (Adaptee adaptee) { this.adaptee = adaptee; } public void request() { // 这里是使用委托的方式完成特殊功能 this.adaptee.specificRequest(); }} // 测试类public class Client { public static void main(String[] args) { // 使用普通功能类 Target concreteTarget = new ConcreteTarget(); concreteTarget.request(); // 使用特殊功能类，即适配类， // 需要先创建一个被适配类的对象作为参数 Target adapter = new Adapter(new Adaptee()); adapter.request(); }} Adapter 存储Adaptee 地址,客户调用Adapter接口,Adapter 再调用Adaptee接口. 优点 不需要客户端做改变,可以直接调用接口 复用现存类,解决环境和现存类接口不一问题 解耦target和adaptee 同一个适配器可以把适配者类和它的子类都适配到目标接口。 缺点对于对象适配器来说，更换适配器的实现过程比较复杂。(为什么呢?挺简单的吧) 适用场景 现存类的接口不符合系统的接口 旧的系统开发的类已经实现了一些功能，但是客户端却只能以另外接口的形式访问，但我们不希望手动更改原有类的时候。 使用第三方组件，组件接口定义和自己定义的不同，不希望修改自己的接口，但是要使用第三方组件接口的功能。","link":"/适配器模式.html"},{"title":"设计模式-原型模式","text":"原型模式定义 python也有用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。 原型类条件 实现Cloneable接口.在java虚拟机中,只有实现了这个接口的类才可以被拷贝,否则CloneNotSupportedException 重写clone方法:Object类,有一个clone方法,但是是protect类型,重写变为public类型. 实现代码123456789101112131415161718192021222324252627class Prototype implements Cloneable { public Prototype clone(){ Prototype prototype = null; try{ prototype = (Prototype)super.clone(); }catch(CloneNotSupportedException e){ e.printStackTrace(); } return prototype; } } class ConcretePrototype extends Prototype{ public void show(){ System.out.println(\"原型模式实现类\"); } } public class Client { public static void main(String[] args){ ConcretePrototype cp = new ConcretePrototype(); for(int i=0; i&lt; 10; i++){ ConcretePrototype clonecp = (ConcretePrototype)cp.clone(); clonecp.show(); } } } 优点 性能优于new.clone方法是一个本地方法,直接操作内存的二进制流(如果是特别大的对象,性能的差别非常明显) 简化对象创建,复制粘贴就好 适用环境 重复地创建相似对象时可以考虑使用原型模式 注意事项 clone不会调用 构造方法 无视构造方法权限,直接复制(对应private 构造方法导致单例的情况) 深拷贝:拷贝八种基本数据类型(byte,char,short,int,long,float,double，boolean) 对于数组、容器对象、引用对象等都不会拷贝，这就是浅拷贝 这很像python啊 浅拷贝的解决办法12345678910111213public class Prototype implements Cloneable { private ArrayList list = new ArrayList(); public Prototype clone(){ Prototype prototype = null; try{ prototype = (Prototype)super.clone(); prototype.list = (ArrayList) this.list.clone(); }catch(CloneNotSupportedException e){ e.printStackTrace(); } return prototype; } }","link":"/设计模式-原型模式.html"},{"title":"门面模式","text":"门面模式介绍 组成:client,Facade,modules 解决问题:子模块过多,客户调用复杂 解决方案:引入facade,客户只知道facade,简化系统复杂性,modules只知道facade,并把它当做客户. 优点 降低耦合度 降低了client和modules的耦合度,使modules更容易扩展和维护. 简单易用 使子系统更易用,client不再需要和子系统交互. 更好的划分访问层次 通过合理使用Facade，可以帮助我们更好地划分访问的层次。有些方法是对系统外的，有些方法是系统内部使用的。把需要暴露给外部的功能集中到门面中，这样既方便客户端使用，也很好地隐藏了内部的细节。 组成Modules12345678910111213141516171819public class ModuleA { //示意方法 public void testA(){ System.out.println(\"调用ModuleA中的testA方法\"); }}public class ModuleB { //示意方法 public void testB(){ System.out.println(\"调用ModuleB中的testB方法\"); }}public class ModuleC { public void testC(){ System.out.println(\"调用ModuleC中的testC方法\"); }} Facade12345678910public class Facade_in { public void test(){ ModuleA a = new ModuleA(); a.testA(); ModuleB b = new ModuleB(); b.testB(); ModuleC c = new ModuleC(); c.testC(); } } 调用12345678public void run(){ new Facade_in().test();}public static void main(String[] args) { new Facade().run();}","link":"/门面模式.html"},{"title":"阿里云v2ray","text":"清空1234#全新的安装sudo curl -sSL https://raw.githubusercontent.com/MeowLove/AlibabaCloud-CentOS7-Pure-and-safe/master/download/kill/New_installation.sh | sudo bash# 重启 安装锐速第二部sudo curl -sSL https://raw.githubusercontent.com/MeowLove/AlibabaCloud-CentOS7-Pure-and-safe/master/download/LotServer/install_step2.sh | sudo bash 未删完123/usr/local/cloudmonitor/CmsGoAgent.linux-amd64 stop/usr/local/cloudmonitor/CmsGoAgent.linux-amd64 uninstallrm -rf /usr/local/cloudmonitor 防火墙配置123456789101112131415161718192021222324252627282930313233343536373839#允许来自于lo接口的数据包 #如果没有此规则，你将不能通过127.0.0.1访问本地服务，例如ping 127.0.0.1 iptables -Fiptables -Xiptables -t nat -Fiptables -t nat -Xiptables -t mangle -Fiptables -t mangle -Xiptables -t raw -Fiptables -t raw -Xiptables -t security -Fiptables -t security -Xiptables -P INPUT ACCEPTiptables -P FORWARD ACCEPTiptables -P OUTPUT ACCEPT#禁用云盾iptables -I INPUT -s 140.205.201.0/28 -j DROPiptables -I INPUT -s 140.205.201.16/29 -j DROPiptables -I INPUT -s 140.205.201.32/28 -j DROPiptables -I INPUT -s 140.205.225.192/29 -j DROPiptables -I INPUT -s 140.205.225.200/30 -j DROPiptables -I INPUT -s 140.205.225.184/29 -j DROPiptables -I INPUT -s 140.205.225.183/32 -j DROPiptables -I INPUT -s 140.205.225.206/32 -j DROPiptables -I INPUT -s 140.205.225.205/32 -j DROPiptables -I INPUT -s 140.205.225.195/32 -j DROPiptables -I INPUT -s 140.205.225.204/32 -j DROP#常用iptables -A OUTPUT -p tcp --match multiport --sports 22,80,443 -j ACCEPTiptables -A INPUT -p tcp --match multiport --dports 22,80,443 -j ACCEPTiptables -A INPUT -i lo -p all -j ACCEPT iptables -A OUTPUT -o lo -p all -j ACCEPTiptables -A INPUT -p icmp -j ACCEPTiptables -A OUTPUT -p icmp -j ACCEPTiptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT#禁用iptables -P INPUT DROP 保存配置1234systemctl enable v2raysystemctl enable nginxsystemctl enable iptablesservice iptables save 链接https://www.moerats.com/archives/625/ https://github.com/MeowLove/AlibabaCloud-CentOS7-Pure-and-safe 锐速、BBR和BBR_POWERED（魔改）对比测试","link":"/阿里云v2ray.html"},{"title":"git_pre_commit","text":"git pre commit 钩子在HEXO的使用需求分析1234567.├── public├── source└── themes ├── icarus │ └── _config.yml └── icarus.yml hexo 目录结构如上,hexo 根目录已初始化为git项目,icarus为子模块.出于更新,pull考虑,icarus项目没有把icarus 的配置文件_config.yml放到git中.但是由于icarus为子模块,所以主模块也无法add icarus的配置文件.但是为了保存icarus的配置文件,我们必须要添加到git中,以方便同步和备份 解决方案 在theme目录下备份 _config.yml 为icarus.yml 添加pre commit hook 1234567#!/bin/shif ! diff themes/icarus.yml themes/icarus/_config.yml &amp;&gt; /dev/null ; then cp themes/icarus/_config.yml themes/icarus.yml git add themes/icarus.ymlfi 每次commit的时候都会检查_config.yml是否改变,改变则更新icarus.yml 并add 最终每次commit都可以保证配置文件的更新","link":"/git-pre-commit.html"},{"title":"archlinux_transparent_proxy","text":"Arch linux v2ray 透明代理本文适用对象:PC翻墙(和网关翻墙相对),linux系统,v2ray 优点 linux系统全局走代理,而不仅仅是浏览器,这样git,pip,wget,telegram等等都能得到加速 总体框架服务端: nginx+v2ray 客户端: iptables+dnsmasq+v2ray 协议: WebSocket+TLS+Web(伪装能力MAX) 服务器配置,看官方文档,不是本文重点,以后可能会写透明代理配置v2ray inbounds配置 port:v2ray为iptables监听的端口,iptables的流量会转到这来 12345678910111213{ \"port\": 12345, \"listen\": \"127.0.0.1\", \"protocol\": \"dokodemo-door\", \"settings\": { \"network\": \"tcp,udp\", \"followRedirect\": true }, \"sniffing\": { \"enabled\": true, \"destOverride\": [\"http\", \"tls\"] }} v2ray 路由配置12345678910111213141516171819202122232425262728293031323334353637\"routing\": { \"domainStrategy\": \"IPIfNonMatch\", \"rules\": [ {//dns协议走dns-out出,下文dns配置会用到 \"type\": \"field\", \"inboundTag\": [\"dns-in\"], \"outboundTag\": \"dns-out\" }, {//外网dns走代理,防污染 \"type\": \"field\", \"outboundTag\": \"proxy\", \"ip\": [ \"1.1.1.1\", \"8.8.8.8\" ] }, {//广告域名屏蔽,ps:有部分域名误判 \"type\": \"field\", \"domain\": [\"geosite:category-ads\"], \"outboundTag\": \"blocked\" }, {//国内域名直连 \"type\": \"field\", \"outboundTag\": \"direct\", \"domain\": [\"geosite:cn\"] }, {//国内ip直连 \"type\": \"field\", \"outboundTag\": \"direct\", \"ip\": [ \"geoip:cn\", \"geoip:private\" ] } ], \"strategy\": \"rules\" }, V2ray outbounds配置 在所有的outbounds中的”streamSettings”添加 123 \"sockopt\": { \"mark\": 255 //这里是 SO_MARK，用于 iptables 识别，每个 outbound 都要配置；255可以改成其他数值，但要与下面的 iptables 规则对应；如果有多个 outbound，最好奖所有 outbound 的 SO_MARK 都设置成一样的数值 iptables设置 网关设备开启 IP 转发。在 /etc/sysctl.conf 文件添加一行 net.ipv4.ip_forward=1 ，执行下列命令生效： 1sysctl -p 设定 TCP 透明代理的 iptables 规则，命令如下(#代表注释)： 123456iptables -t nat -N V2RAY # 新建一个名为 V2RAY 的链iptables -t nat -A V2RAY -d 127.0.0.1/32 -j RETURNiptables -t nat -A V2RAY -d 192.168.0.0/16 -j RETURN # 直连 192.168.0.0/16 iptables -t nat -A V2RAY -p tcp -j RETURN -m mark --mark 0xff # 直连 SO_MARK 为 0xff 的流量(0xff 是 16 进制数，数值上等同与上面配置的 255)，此规则目的是避免代理本机(网关)流量出现回环问题iptables -t nat -A V2RAY -p tcp -j REDIRECT --to-ports 12345 # 其余流量转发到 12345 端口（即 V2Ray）iptables -t nat -A OUTPUT -p tcp -j V2RAY # 对本机进行透明代理 不建议设置udp全局代理,我个人目前还没有遇到需要udp代理的情况,但是开启udp代理可能会对本机造成一些影响 docker node dns解析失败(待验证,目前知道的情况是 docker也用到了iptables可能和v2ray的udp全局产生了冲突) 至此本机应该可以实现透明代理了,但是dns解析还有问题DNS配置由于dns污染的存在,即使ip可以透明代理,本机也无法正常上网. v2ray inbounds 添加dns接口至于每个配置到底是啥意思,请看官方文档,官方文档写的非常不错 12345678910{ \"port\": 54,//端口可以填53,直接把v2ray作为dns解析,但是v2ray dns存在缺点,所以为了和dnsmasq配合,使用了54端口 \"tag\": \"dns-in\", \"protocol\": \"dokodemo-door\", \"settings\": { \"address\": \"1.1.1.1\", \"port\": 53, \"network\": \"tcp,udp\" }} v2ray outbounds 添加dns出口123456789{ \"tag\": \"dns-out\", \"protocol\": \"dns\", \"settings\": { \"network\": \"tcp\", \"address\": \"1.1.1.1\", \"port\": 53 } } v2ray dns模块1234567891011121314151617181920212223242526272829303132333435 \"dns\": { \"hosts\": {//hosts \"domain:v2ray.com\": \"www.vicemc.net\", \"domain:github.io\": \"pages.github.com\", \"domain:wikipedia.org\": \"www.wikimedia.org\", \"domain:shadowsocks.org\": \"electronicsrealm.com\" }, \"servers\": [ \"1.1.1.1\", {//国内域名走114 \"address\": \"114.114.114.114\", \"port\": 53, \"domains\": [ \"geosite:cn\" ] }, \"8.8.8.8\", \"localhost\" ] }, \"policy\": { \"levels\": { \"0\": { \"uplinkOnly\": 0, \"downlinkOnly\": 0 } }, \"system\": { \"statsInboundUplink\": false, \"statsInboundDownlink\": false } }, \"other\": {}} 至此dns已经可以用了到这,dns污染问题已经解决了,可以通过如下命令检测 1dig @127.0.0.1 -p 54 www.google.com 但是正如v2ray文档所言,v2ray 内建dns支持A,AAAA方式的域名,所以会出现部分域名无法解析的情况 下面的这个域名采用soa方式,v2ray就无法解析了,两条命令的结果对比一下就可以看到了 12dig @8.8.8.8 gowdb.indig @127.0.0.1 -p 54 gowdb.in 下面就要dnsmasq出场了,其实v2ray可以把dns再完善完善,这样就v2ray就完美了.有志青年们可以搞搞go啊,完善v2ray,再弄个kunlikunli,嘿嘿嘿嘿. dnsmasq出场总体设想:dnsmasq,gfw域名走v2ray解析,其他域名走114 引入轮子:https://github.com/cokebar/gfwlist2dnsmasq 1234#别想着复制代码,自己clone下来,执行#/etc/dnsmasq.d 没有这个文件夹的#sudo mkdir /etc/dnsmasq.dsudo sh gfwlist2dnsmasq.sh -d 127.0.0.1 -p 54 -o /etc/dnsmasq.d/gfw.conf 接着在/etc/dnsmasq.conf最后添加 123server=117.50.11.11server=117.50.22.22conf-dir=/etc/dnsmasq.d server可以填自己喜欢的dns 至此 dns已经完美了","link":"/archlinux-transparent-proxy.html"},{"title":"firewalld下不同网卡端口转发","text":"firewalld 原生端口转发(不支持不同网卡间转发)先说一下环境: 本机ip 202.112.159.24 需要把本机的80端口转发到本机的8080端口 需要把本机的443端口转发到同网卡202.112.159.33的443端口 首先允许端口进入 firewalldfirewall-cmd –permanent –zone=public –add-port=8080/tcp 允许防火墙伪装ip1firewall-cmd --add-masquerade --permanent –add-masquerade:我的理解是 在 端口转发的时候把源包的来源地址更改为本机ip地址(iptables 自动获取本机ip) premanent选项是永久添加规则,但是不会立即生效,需要reload ## firewalld 下使用iptables 双网卡 端口转发123iptables -t nat -I PREROUTING -p tcp -m tcp --dport 9001 -j DNAT --to-destination 192.168.122.10:22iptables -t nat -I POSTROUTING -d 192.168.122.10 -p tcp -m tcp --dport 22 -j MASQUERADEiptables -t filter -I FORWARD -o virbr0 -d 192.168.122.10 -p tcp -m tcp --dport 22 -j ACCEPT 123iptables -t nat -I PREROUTING -p tcp -m tcp --dport 9002 -j DNAT --to-destination 192.168.122.10:22iptables -t nat -I POSTROUTING -d 192.168.122.10 -p tcp -m tcp --dport 22 -j MASQUERADEiptables -t filter -I FORWARD -o virbr0 -d 192.168.122.10 -p tcp -m tcp --dport 22 -j ACCEPT firewalld directbuilt_in表竟然是加到了*_direct表里,有毛用,放弃firewalld了 12345firewall-cmd --permanent --direct --add-rule ipv4 nat PREROUTING 0 -p tcp -m tcp --dport 9001 -j DNAT --to-destination 192.168.122.10:22firewall-cmd --permanent --direct --add-rule ipv4 nat POSTROUTING 0 -d 192.168.122.10 -p tcp -m tcp --dport 22 -j MASQUERADEfirewall-cmd --permanent --direct --add-rule ipv4 filter FORWARD 0 -o virbr0 -d 192.168.122.10 -p tcp -m tcp --dport 22 -j ACCEPT 改用iptables删除firewalld1234#停止firewalld服务systemctl stop firewalld#禁用firewalld服务systemctl mask firewalld 安装 iptables12345678#先检查是否安装了iptablesservice iptables status#安装iptablesyum install -y iptables#升级iptablesyum update iptables #安装iptables-servicesyum install iptables-services 删除所有规则1234567891011121314151617181920212223242526272829303132333435363738iptables -t nat -F iptables -t nat -X iptables -t nat -P PREROUTING ACCEPT iptables -t nat -P POSTROUTING ACCEPT iptables -t nat -P OUTPUT ACCEPT iptables -t mangle -F iptables -t mangle -X iptables -t mangle -P PREROUTING ACCEPT iptables -t mangle -P INPUT ACCEPT iptables -t mangle -P FORWARD ACCEPT iptables -t mangle -P OUTPUT ACCEPT iptables -t mangle -P POSTROUTING ACCEPT iptables -F iptables -X iptables -P FORWARD ACCEPT iptables -P INPUT ACCEPT iptables -P OUTPUT ACCEPT iptables -t raw -Fiptables -t raw -Xiptables -t raw -P PREROUTING ACCEPTiptables -t raw -P OUTPUT ACCEPT 设置规则12345678iptables -A INPUT -i lo -j ACCEPTiptables -A INPUT -p tcp --dport 22 -j ACCEPTiptables -A INPUT -p tcp --dport 80 -j ACCEPTiptables -A INPUT -p tcp --dport 443 -j ACCEPTiptables -A INPUT -p icmp --icmp-type 8 -j ACCEPTiptables -P INPUT DROPiptables -P OUTPUT ACCEPTiptables -P FORWARD DROP 123456789#测试#iptables -A INPUT -m set --match-set bjtu src -j DROPiptables -A INPUT -p tcp -m multiport --dports 80,443 -m state --state NEW,ESTABLISHED -j ACCEPTiptables -A OUTPUT -p tcp -m multiport --sports 80,443 -m state --state ESTABLISHED -j ACCEPT nginx 反向代理 允许 80 443端口开启22,80,443 123456789101112131415161718192021222324252627282930313233343536373839# 重要重要优先 22端口iptables -A INPUT -p tcp --dport 22 -m set --match-set bjtu src -m state --state NEW,ESTABLISHED -j ACCEPTiptables -A OUTPUT -p tcp --sport 22 -m set --match-set bjtu src -m state --state ESTABLISHED -j ACCEPT## 允许来自guest的返回#抛弃该种方式,采用ipset#iptables -A INPUT -p tcp -s 192.168.122.10 -j ACCEPT#iptables -A INPUT -p tcp -s 192.168.122.12 -j ACCEPT#iptables -A OUTPUT -p tcp -d 192.168.122.10 -j ACCEPT#iptables -A OUTPUT -p tcp -d 192.168.122.12 -j ACCEPTiptables -A INPUT -m set --match-set kvm_guest src -j ACCEPTiptables -A OUTPUT -m set --match-set kvm_guest src -j ACCEPT#ipables log功能#iptables -A INPUT -j LOG --log-prefix \"INPUT:DROP:\" --log-level 6## 允许80,443端口访问iptables -A INPUT -p tcp -m multiport --dports 80,443 -m state --state NEW,ESTABLISHED -j ACCEPTiptables -A OUTPUT -p tcp -m multiport --sports 80,443 -m state --state ESTABLISHED -j ACCEPT#允许ping#iptables -A INPUT -p icmp --icmp-type echo-request -j ACCEPT#iptables -A OUTPUT -p icmp --icmp-type echo-reply -j ACCEPTiptables -A INPUT -p icmp --icmp-type echo-request -j ACCEPTiptables -A OUTPUT -p icmp --icmp-type echo-reply -j ACCEPT#允许dnsiptables -A INPUT -p udp -m udp --sport 53 -j ACCEPTiptables -A OUTPUT -p udp -m udp --dport 53 -j ACCEPT#配置端口转发iptables -t nat -I PREROUTING -p tcp -m tcp --dport 9001 -m set --match-set bjtu src -j DNAT --to-destination 192.168.122.10:22iptables -t nat -I POSTROUTING -d 192.168.122.10 -p tcp -m tcp --dport 22 -m set --match-set bjtu src -j MASQUERADE# 最后添加默认规则iptables -P INPUT DROPiptables -P OUTPUT DROP#iptables -P FORWARD DROP iptables 默认表 filteriptables 禁用dhcp导致 kvm ssh 无法访问临时解决办法 123456iptables -A INPUT -p udp -s 192.168.122.10 -j ACCEPTiptables -A INPUT -p udp -s 192.168.122.11 -j ACCEPTiptables -A INPUT -p udp -s 192.168.122.12 -j ACCEPTiptables -A OUTPUT -p udp -d 192.168.122.10 -j ACCEPTiptables -A OUTPUT -p udp -d 192.168.122.11 -j ACCEPTiptables -A OUTPUT -p udp -d 192.168.122.12 -j ACCEPT 优化使用ipset 12345ipset -N kvm_guest nethashipset add kvm_guest 192.168.122.1/24iptables -A INPUT -m set --match-set kvm_guest src -j ACCEPTiptables -A OUTPUT -m set --match-set kvm_guest src -j ACCEPT 草稿 1234567891011121314151617iptables -A INPUT -p udp -m udp --sport 53 -j ACCEPTiptables -A OUTPUT -p udp -m udp --dport 53 -j ACCEPTiptables -t filter -A INPUT -p dhcp -j ACCEPTiptables -t filter -A OUTPUT -p dhcp -j ACCEPTiptables -t filter -A INPUT -p icmp -j ACCEPTiptables -t filter -A OUTPUT -p icmp -j ACCEPTiptables -I INPUT -p udp --dport 67:68 --sport 67:68 -j ACCEPTiptables -I OUTPUT -p udp --dport 67:68 --sport 67:68 -j ACCEPTiptables -A INPUT -p udp -s 192.168.122.10 -j ACCEPTiptables -A INPUT -p udp -s 192.168.122.12 -j ACCEPTiptables -A OUTPUT -p udp -d 192.168.122.10 -j ACCEPTiptables -A OUTPUT -p udp -d 192.168.122.12 -j ACCEPT iptables 禁用icmp会导致sendmsg: Operation not permitted 收尾阶段1234#ip set持久化systemctl enable iptabelsservice iptables save 参考链接tcpdump用法tcpdump用法 Linux之iptables详解及tcpdump iptables 入门iptables非常容易理解的结构图 arch wiki 讲得不错,入门可以,但是不全) Linux之iptables详解及tcpdump,非常全 常见iptables使用规则场景整理 ptables 添加，删除，查看，修改 iptables 端口转发linux下用iptables做本机端口转发方法 Centos 6 + iptables 作为网关NAT转发、端口转发笔记","link":"/firewalld下不同网卡端口转发.html"}],"tags":[{"name":"python","slug":"python","link":"/tags/python/"}],"categories":[{"name":"设计模式","slug":"设计模式","link":"/categories/设计模式/"},{"name":"安全","slug":"安全","link":"/categories/安全/"},{"name":"运维","slug":"运维","link":"/categories/运维/"},{"name":"python","slug":"python","link":"/categories/python/"},{"name":"web","slug":"安全/web","link":"/categories/安全/web/"},{"name":"asyncio","slug":"python/asyncio","link":"/categories/python/asyncio/"},{"name":"linux","slug":"linux","link":"/categories/linux/"},{"name":"csrf","slug":"安全/web/csrf","link":"/categories/安全/web/csrf/"},{"name":"vps","slug":"vps","link":"/categories/vps/"},{"name":"开发","slug":"开发","link":"/categories/开发/"},{"name":"防火墙","slug":"linux/防火墙","link":"/categories/linux/防火墙/"},{"name":"git","slug":"开发/git","link":"/categories/开发/git/"}]}